---
title: "09 practice"
output: html_document
---

```{r}
generate_data <- function (N, dist, sh, sc) {
  if (dist == "norm"){
    rnorm(N)
  }else if(dist == "gamma"){
    rgamma(N,shape=sh,scale=sc)
  }
}
```

```{r}
data <- rnorm(201)
R <-10
estimate_ci <- function(data, mod, par.int, R=10, smoo = 0.3) {
  N <- length(data)
  sum.measure <- get(par.int)
  if (mod == "MMnorm"){
    mm.mean <- mean(data)
    mm.sd <- sd(data)
    # repeate this bad boi 5k times
    
    samp.dist <- NA
    for(i in 1:R) {
      sim.data <- rnorm(length(data), mm.mean, mm.sd)
      if (par.int == "median") {
        samp.dist[i] <- median(sim.data)
      }else if (par.int == "min") {
        samp.dist[i] <- min(sim.data)
      }
    }
    return(quantile(samp.dist, c(0.05,0.95)))
    
    
  }else if(mod == "MMgamma"){
    # mean of data has to be positive for this to work!
    # this will git some NANs cause you cant do gamma with <0 shape or scale
    mm.shape <- mean(data)^2/var(data)
    mm.scale <- var(data)/mean(data)
    # repeat this 5k times
    
    
    sim.data <- array(rgamma(length(data)*R, shape = mm.shape, scale = mm.scale), dim = c(N,R))
    samp.dist <- apply(sim.data, 2, FUN = sum.measure)

    
  }else if(mod == "KDE"){
    # chapter 8 in his notes october 9th -
    ecdfstar <- function(t, data, smooth = smoo){
      outer(t, data, function(a,b){pnorm(a,b,smooth)}) %>% rowMeans
    }
    
    tbl <- data.frame(
      # range.x <- range(data)
      x = seq(min(data)-sd(data), max(data)+sd(data),by=0.01)
    )
    tbl$p <- ecdfstar(tbl$x, bmi, smoo)
    tbl <- tbl[!duplicated(tbl$p),]
    
    qkde <- function(ps, tbl){
      rows <- cut(ps, tbl$p, labels = FALSE)
      tbl[rows, "x"]
    }
    
    U <- runif(N*R)
    
    sim.data <- array(qkde(U, tbl), dim=c(N,R))
    samp.dist <- apply(sim.data, 2, sum.measure)
    return(quantile(samp.dist, c(0.05,0.95)))

  }else if(mod == "Boot"){
    # repeat 5k times
    sim.data <- sample(data, N, replace=TRUE)
  }
  return()
}
```

```{r}
capture_par <- function(ci, true.par){
  1*(ci[1]<true.par & true.par<ci[2])
}

N <- 201
shape <- 1.4


true.norm.med <- qnorm(0.5)
true.norm.min <- mean(apply(array(rnorm(N*10000), dim=c(N,10000)),2,min))
true.gamma.med <- qgamma(0.5, shape = 1.4, scale = 3)
true.gamma.min <- mean(apply(array(rgamma(N*10000, shape = 1.4, scale=3), dim=c(N,10000)),2,min))
  

```

```{r}
simsettings <- expand.grid(dist=c("norm","gamma"), model=c("MMnorm","MMgamma","KDE","Boot"), par.int=c("median", "min"), cov.prob=NA, stringsAsFactors = FALSE, KEEP.OUT.ATTRS = FALSE)
```

```{r}
for (k in 1:nrow(simsettins)) {
dist1 <- simsettings[k,1]
model1 <- simsettings[k,2]
par.int1 <- simsettings[k,3]
# repeate this bad boi 5k times and take avg

if (dist1=="norm"&par.int1 =="median") {
  true.par1 <- treu.norm.med
}else if () {
  # add in all other params
}

cover <- NA
for(sims in 1:10) {
  cover[sims] <- generate_data(N, dist1) %>% estimate_ci(mod=model1, par.int=par.int1) %>% capture_par(true.par = true.par1)
}
simsettings[k,4] <- mean(cover)
}
```


